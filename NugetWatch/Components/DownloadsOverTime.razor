@implements IDisposable

<div class="downloads-over-time">
    @{
        var width = Entries.Length / 7;
        var height = 7;
        var i = 0;
    }
    @for (var x = 0; x < width; x++)
    {
        <div class="over-time-week">
            @for (var y = 0; y < height; y++)
            {
                if (Entries.Length <= i) break;
                var entry = Entries[i];
                var classes = new List<string> { "over-time-day" };
                var future = i > boxCountUsed;
                if (future) classes.Add("over-time-future");
                var date = entry == null ? DateTimeOffset.MinValue : entry.Date;
                var isFirst = date.Day == 1;
                var downloads = entry == null ? 0 : entry.Downloads;
                var bgColor = entry == null ? null : entry.BGColor;
                var title = $"{downloads} - {date.Date.ToShortDateString()}";
                var style = "";
                if (entry?.IsToday == true) classes.Add("over-time-today");
                if (isFirst) classes.Add("over-time-first");
                if (!future && !string.IsNullOrEmpty(bgColor)) style += $"background-color: {bgColor};";
                if (entry?.PublishedVersions.Any() == true)
                {
                    classes.Add("over-time-publish");
                    title += $" {string.Join(", ", entry.PublishedVersions)}";
                }
                i++;
                <div style="@style" class="@(string.Join(" ", classes))" title="@title"></div>
            }
        </div>
    }
</div>

@code {

    [Inject]
    NugetMonitorService NugetMonitorService { get; set; } = default!;

    [Inject]
    NugetService NugetService { get; set; } = default!;

    [Parameter]
    public NugetPackageData PackageData { get; set; } = default!;

    DateTime DayOfWeekOrNext(DateTime date, DayOfWeek dayOfWeek = DayOfWeek.Sunday)
    {
        var daysFrom = dayOfWeek - date.DayOfWeek;
        if (daysFrom < 0) daysFrom += 7;
        var ret = date + TimeSpan.FromDays(daysFrom);
        return ret;
    }

    string _DataKey = "";

    Entry[] Entries = new Entry[371];
    int boxCountUsed = 0;
    int dayOfYear = 0;

    DateTime startingSunday;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_DataKey != PackageData.DataKey || dayOfYear != DateTime.Now.DayOfYear)
        {
            dayOfYear = DateTime.Now.DayOfYear;
            _DataKey = PackageData.DataKey;
            await Refresh();
        }
    }
    bool _beenInit = false;
    protected override void OnInitialized()
    {
        if (!_beenInit)
        {
            _beenInit = true;
            //NugetMonitorService.OnPackageChange += NugetMonitorService_OnPackageChange;
        }
    }
    void NugetMonitorService_OnPackageChange(List<NugetPackageChangeEventArg> packages)
    {
        StateHasChanged();
    }
    public void Dispose()
    {
        if (_beenInit)
        {
            _beenInit = false;
            //NugetMonitorService.OnPackageChange += NugetMonitorService_OnPackageChange;
        }
    }
    class Entry
    {
        public DateTimeOffset Date { get; set; }
        public long Downloads { get; set; }
        public string BGColor { get; set; }
        public bool IsToday { get; set; }
        public List<string> PublishedVersions { get; set; }
    }
    List<NugetPackageData> AllData = new List<NugetPackageData>();

    NugetPackageData? GetFromDBByDataTimeStamp(DateTimeOffset asOf)
    {
        return AllData.OrderByDescending(o => o.DataTimeStampLong).FirstOrDefault(o => o.DataTimeStamp <= asOf);
    }
    List<NugetPackageData> GetFromDBByDataTimeStamp(DateTimeOffset min, DateTimeOffset max)
    {
        return AllData.Where(o => o.DataTimeStamp >= min && o.DataTimeStamp <= max).OrderBy(o => o.DataTimeStamp).ToList();
    }
    Dictionary<NugetPackageVersion, DateTimeOffset> GetFromVersionByTimeSpan(DateTimeOffset min, DateTimeOffset max)
    {
        var ret = new Dictionary<NugetPackageVersion, DateTimeOffset>();
        foreach (var v in PackageData.Versions)
        {
            if (VersionsPublished.TryGetValue(v._Id, out var published))
            {
                if (v._Id.Contains("peerjs/1.5.0.json") && Math.Abs((DateTimeOffset.Now - min).TotalHours) <= 24)
                {
                    var wtaf = v._Id;
                    var nmt = true;
                }
                if (published >= min && published <= max)
                {
                    ret.Add(v, published);
                }
            }
        }
        return ret;
    }
    Dictionary<string, DateTimeOffset> VersionsPublished = new Dictionary<string, DateTimeOffset>();
    async Task Refresh()
    {
        var today = DateTime.Now.StartOfDay();
        var boxCountTotal = 365;
        boxCountTotal = (boxCountTotal % 7) > 0 ? boxCountTotal + (7 - (boxCountTotal % 7)) : boxCountTotal;
        var firstDay = today - TimeSpan.FromDays(boxCountTotal - 2);
        startingSunday = DayOfWeekOrNext(firstDay);
        boxCountUsed = (int)Math.Ceiling((today - startingSunday).TotalDays);
        var entries = new Entry[boxCountTotal];
        AllData = await NugetMonitorService.GetFromDBByTitle(PackageData.Title);
        VersionsPublished = await NugetService.GetNugetPackageVersionsPublished(PackageData, startingSunday);
        for (var i = 0; i < boxCountTotal; i++)
        {
            try
            {
                var classes = new List<string> { "over-time-day" };
                if (i > boxCountUsed) classes.Add("over-time-future");
                var date = startingSunday + TimeSpan.FromDays(i);
                var startDate = date.StartOfDay();
                var endDate = date.EndOfDay();
                var isToday = today.Date == startDate.Date;
                // subtract total downloads at beginning of day the from total downloads at end of the day
                var daysData = GetFromDBByDataTimeStamp(startDate, endDate);
                var dataStartOfDay = GetFromDBByDataTimeStamp(startDate) ?? (daysData.Count > 1 ? daysData.First() : null);
                var dataEndOfDay = GetFromDBByDataTimeStamp(endDate);
                var downloadsStartOfDay = dataStartOfDay?.TotalDownloads ?? 0;
                var downloadsEndOfDay = dataEndOfDay?.TotalDownloads ?? 0;
                int downloads = (int)(dataStartOfDay == null || dataEndOfDay == null ? 0 : downloadsEndOfDay - downloadsStartOfDay);
                var colorBumped = downloads * 32;
                int g = Math.Min(colorBumped, 255);
                int r = (int)Math.Min(colorBumped / 255f, 255);
                int b = (int)Math.Min(colorBumped / 65535f, 255);
                var versions = GetFromVersionByTimeSpan(startDate, endDate).Select(o => o.Key.Version).ToList();
                if (isToday && PackageData.Title.Contains("PeerJS"))
                {
                    var nmt = true;
                }
                entries[i] = new Entry
                {
                    Date = startDate,
                    Downloads = downloads,
                    BGColor = $"#{Convert.ToHexString(new byte[] { (byte)r, (byte)g, (byte)b })}",
                    IsToday = isToday,
                    PublishedVersions = versions,
                };
            }
            catch (Exception ex)
            {
                var nmt = ex.ToString();
            }
        }
        Entries = entries;
        StateHasChanged();
    }
}
